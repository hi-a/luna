#!/usr/bin/env python
'''
Written by Dmitry Chirikov <dmitry@chirikov.ru>
This file is part of Luna, cluster provisioning tool
https://github.com/dchirikov/luna

This file is part of Luna.

Luna is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Luna is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Luna.  If not, see <http://www.gnu.org/licenses/>.

'''

import os
import sys
import pwd
import time
import fcntl
import signal
import traceback
import logging

import pymongo
import tornado
import tornado.ioloop
import tornado.web
import tornado.options
import tornado.httpserver

from luna import utils
from luna import MacUpdater, AnnounceHandler, ScrapeHandler, Manager


try:
    log_dir = os.environ['LUNA_LOGDIR']
except KeyError:
    log_dir = '/var/log/luna'

config = utils.helpers.load_configuration()['cluster']

db_name = 'luna'
logger = None
starter_pid = None
http_server = None
pipein, pipeout = None, None
macupdater = None


def lweb_main():
    pass


def run_app():
    """Start Tornado IOLoop for this application.
    """
    global logger
    global pipein, pipeout
    global starter_pid, http_server, macupdater

    tornado.options.parse_command_line()

    if config['frontend_https']:
        protocol = 'https'
    else:
        protocol = 'http'

    if 'frontend_address' not in config:
        logger.error('frontend_address needs to be configured!')
        return None

    manager_params = {}
    manager_params['protocol'] = protocol
    manager_params['server_ip'] = config['frontend_address']
    manager_params['server_port'] = config['frontend_port']
    manager_params['app_logger'] = logger

    tracker_params = {}
    tracker_params['tracker_interval'] = config['tracker_interval']
    tracker_params['tracker_min_interval'] = config['tracker_min_interval']
    tracker_params['tracker_maxpeers'] = config['tracker_maxpeers']

    template_path = config['path'] + '/templates'

    lweb = tornado.web.Application([
        (r"/announce.*", AnnounceHandler, dict(params=tracker_params)),
        (r"/scrape.*", ScrapeHandler, dict(params=tracker_params)),
        (r"/luna.*", Manager, dict(params=manager_params)),
    ], template_path=template_path, xheaders=True)

    logger.info('Starting lweb on port %s' % config['lweb_port'])

    conn_options = utils.helpers.get_con_options()
    while True:
        try:
            db = pymongo.MongoClient(**conn_options)[db_name]
        except:
            logger.error("Unable to connect to MongoDB. Retrying ...")
            time.sleep(10)
            continue
        break

    try:
        db['tracker'].create_index("updated", expireAfterSeconds=3600)
    except:
        pass

    macupdater = MacUpdater(db, logger=logger, interval=30)
    http_server = tornado.httpserver.HTTPServer(lweb)
    http_server.bind(config['lweb_port'], address='127.0.0.1')
    http_server.start(int(config['lweb_workers']))

    starter_pid = os.getpid()
    child_pid = os.getpid()
    if starter_pid != child_pid:
        os.close(pipein)
        os.write(pipeout, str(child_pid) + "\n")

    tracker_params['mongo_db'] = db
    manager_params['mongo_db'] = db
    tornado.ioloop.IOLoop.instance().start()


def tornado_stop():
    global http_server
    http_server.stop()

    io_loop = tornado.ioloop.IOLoop.instance()

    deadline = time.time() + 3

    def stop_loop():
        now = time.time()
        if now < deadline and (io_loop._callbacks or io_loop._timeouts):
            io_loop.add_timeout(now + 1, stop_loop)
        else:
            io_loop.stop()
    stop_loop()


def sigterm_handler(sig, frame):
    global pipein, starter_pid, macupdater

    if os.getpid() == starter_pid:
        f_pipein = os.fdopen(os.dup(pipein))
        logger.info('Main thread. Trying to stop childs')
        tornado_stop()
        try:
            for pid in f_pipein:
                pid = int(pid[:-1])
                logger.info("Stopping pid '{}'.".format(pid))
                os.kill(pid, signal.SIGTERM)
        except IOError:
            pass

        f_pipein.close()
        macupdater.stop()
    else:
        tornado_stop()


def daemonize():
    """
    do the UNIX double-fork magic, see Stevens' "Advanced
    Programming in the UNIX Environment" for details (ISBN 0201563177)
    http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16
    """

    log_handler = logging.handlers.RotatingFileHandler(log_dir + '/lweb.log',
                                                       maxBytes=1073741824,
                                                       backupCount=5)
    logger.propagate = False
    formatter = logging.Formatter("%(asctime)s\t%(levelname)s\t%(message)s")
    log_handler.setFormatter(formatter)
    logger.addHandler(log_handler)

    if tornado.version_info[0] > 3:
        tornado.options.options.log_to_stderr = False
        tornado.options.options.log_file_prefix = log_dir + '/lweb_tornado.log'
        tornado.options.options.log_file_max_size = 1073741824
        tornado.options.options.log_file_num_backups = 5
    else:
        tornado.options.options['log_to_stderr'].set(False)
        tornado.options.options['log_file_prefix'].set(log_dir + '/lweb_tornado.log')
        tornado.options.options['log_file_max_size'].set(1073741824)
        tornado.options.options['log_file_num_backups'].set(5)

    stdin = '/dev/null'
    stdout = '/dev/null'
    stderr = '/dev/null'
    logger.info("Starting lweb as daemon")
    try:
        pid = os.fork()
        if pid > 0:
            # exit first parent
            sys.exit(0)
    except OSError, e:
        logger.error("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)

    # decouple from parent environment
    os.chdir("/")
    os.setsid()
    os.umask(0)

    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError, e:
        logger.error("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
        sys.exit(1)

    # redirect standard file descriptors
    sys.stdout.flush()
    sys.stderr.flush()
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

    # write pidfile
    pid = str(os.getpid())

    logger.info("lweb pid: '{}'".format(pid))
    logger.info("lweb pidfile: '{}'".format(config['lweb_pidfile']))
    f = open(config['lweb_pidfile'], "w+")
    f.write("%s\n" % pid)
    f.close()


def start():
    """
    Start the daemon
    """
    global pipein, pipeout

    logger.info("Starting lweb")

    # Check for a pidfile to see if the daemon already runs
    try:
        utils.helpers.check_path(os.path.dirname(config['lweb_pidfile']),
                                 config['user'], logger)
        pf = file(config['lweb_pidfile'], 'r')
        pid = int(pf.read().strip())
        pf.close()
    except IOError:
        pid = None

    user_id = pwd.getpwnam(config['user'])
    os.setgid(user_id.pw_gid)
    os.setuid(user_id.pw_uid)
    if pid:
        message = "pidfile %s already exist. Daemon already running?\n"
        sys.stderr.write(message % config['lweb_pidfile'])
        sys.exit(1)

    # Start the daemon
    pipein, pipeout = os.pipe()
    fcntl.fcntl(pipein, fcntl.F_SETFL, os.O_NONBLOCK)
    if daemon:
        daemonize()
        signal.signal(signal.SIGTERM, sigterm_handler)
        try:
            run_app()
        except Exception as e:
            logger.error(traceback.format_exc(e))
    else:
        try:
            run_app()
        except KeyboardInterrupt:
            logger.info('Lweb Stopped.')
            sys.exit(0)


def stop():
    """
    Stop the daemon
    """
    # Get the pid from the pidfile
    logger.info("Stopping lweb")
    try:
        pf = file(config['lweb_pidfile'], 'r')
        pid = int(pf.read().strip())
        pf.close()
    except IOError:
        pid = None

    if not pid:
        message = "pidfile %s does not exist. Daemon not running?\n"
        logger.error(message % config['lweb_pidfile'])
        return  # not an error in a restart

    # Try killing the daemon process
    try:
        while 1:
            os.kill(pid, signal.SIGTERM)
            time.sleep(0.1)
    except OSError, err:
        err = str(err)
        if err.find("No such process") > 0:
            if os.path.exists(config['lweb_pidfile']):
                os.remove(config['lweb_pidfile'])
        else:
            logger.error(err)
            sys.exit(1)


def restart():
    """
    Restart the daemon
    """
    stop()
    start()


if __name__ == '__main__':
    logger = logging.getLogger('lweb')

    if tornado.version_info[0] > 3:
        tornado.options.options.log_to_stderr = False
    else:
        tornado.options.options['log_to_stderr'].set(False)

    tornado.options.options.log_to_stderr = True

    try:
        daemon = bool(int(os.environ['LWEB_DAEMON']))
    except KeyError:
        daemon = True
    if len(sys.argv) == 2:
        if 'start' == sys.argv[1]:
            start()
        elif 'stop' == sys.argv[1]:
            stop()
        elif 'restart' == sys.argv[1]:
            restart()
        else:
            logger.error("Unknown command")
            sys.exit(2)

        logger.info("Exiting lweb")
        sys.exit(0)

    else:
        logger.error("usage: %s start|stop|restart|reload" % sys.argv[0])
        sys.exit(2)
